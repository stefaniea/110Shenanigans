<html lang="en">
<head>
  <meta charset="utf-8">
  <title>The Body of N</title>
  <link rel="stylesheet" href="../jquery-ui-1.11.0.custom/jquery-ui.min.css">
  <script src="../jquery-2.1.1.js"></script>
  <script src="../jquery-ui-1.11.0.custom/jquery-ui.min.js"></script>
  <link rel="stylesheet" href="/resources/demos/style.css">
  <script>
  $(function() {
    $( "#accordion" ).accordion({collapsible: true, active: false});
     $( "#tabs" ).tabs();
  });
  </script>
</head>
<body>


<div id="tabs">
<ul>
    <li><a href="#part0">Part 0</a></li>
    <li><a href="#part1">Part 1</a></li>
    <li><a href="#part2">Part 2</a></li>
    <li><a href="#part3">Part 3</a></li>
    <li><a href="#part4">Part 4</a></li>
    <li><a href="#part5">Submission</a></li>
  </ul>

<div id="part0">
    <h3>Before You Begin</h3>
    <div class="accordian">
      <h3>Background</h3>
    <div>
      <p>
        <p>In 1687 Sir Isaac Newton formulated the principles governing the the motion of two particles under the influence of their mutual gravitational attraction in his famous <strong>Principia</strong>. However, Newton was unable to solve the problem for three particles. Indeed, in general, systems of three or more particles can only be solved numerically.</p><p> <img src="http://newtontime.weebly.com/uploads/1/4/9/9/14990736/7172854_orig.jpg" alt=" AND YOU THOUGHT YOU KNEW KNEWTON" style="height:100px"></p>
        <p>Your challenge in this assignment is to write a program to simulate the motion of <strong>N </strong>particles in the plane, mutually affected by gravitational forces, and animate the results. Such methods are widely used in cosmology, semiconductors, and fluid dynamics to study complex physical systems. Scientists also apply the same techniques to other pairwise interactions including Coulombic, Biot-Savart, and van der Waals.</p>
        <p>We provide all the formulas you need in the assignment. Don't worry if you don't fully understand them---this is neither a physics nor a math course. Instead, focus on the computer science task: building up a complicated result through a series of simple statements.</p>
      </p>
    </div>
    <h3>Requirements</h3>
    <div>
      <p>When finished this assignment, you should have a program NBody.java that:</p>  
      <ul>
        <li>
         <strong>T</strong>, a double value that represents how long to run the simulation,  
       </li>
       <li>
        <strong>Î”t</strong>, a double value that indicates the amount of time that elapses between simulation steps, and
      </li>
      <li>
        <strong>filename</strong>, the filename for the data file that holds information about the universe.
      </li>
      <li>
        Reads in the universe from the file <strong>filename</strong> using In.java.
      </li>
      <li >
        Simulates the universe, starting at time <strong>t</strong> = 0.0, and continuing as long as <strong>t < T</strong>, using the procedure described later.
      </li>
      <li >
       Animates the results using Processing.
     </li>
     <li>
      Prints the state of the universe at the end of the simulation (in the same format as the input file) to <strong>standard output</strong> using System.out.println().
    </li>
    <li>
      Your program will maintain several parallel arrays to store the data. To make the computer simulation, we will use a loop that repeatedly updates the position and velocity of the particles at each time step <strong>t</strong>.
    </li>
  </ul>
</div>
<h3>A Review of Command-Line Arguments</h3>
<div>
 <ul> 
    <li>For this homework and beyond, you will often have to use
      command-line arguments, which you will have to type in every
      time you run the program.</li>
      <li>Remember that command-line arguments are just an array of
        Strings that are read in automatically to your <code>main()</code>
        function. 
      </li>
      <ul>
        <li>Once <tt>PApplet.main()</tt> is called in your <tt>main()</tt>
          function, the program will not go back to <tt>main()</tt>, so
          any command-line arguments will need to be processed within <tt>main()</tt>
          but before you call <tt>PApplet.main()</tt>.
        </li>
      </ul>
      <ul>
        <li>Since the arguments are read in as Strings, remember also to
          use <tt>Integer.parseInt()</tt> or <tt>Double.parseDouble()</tt>
          to convert numeric arguments to whatever type you need.
        </li>
      </ul>
      <li>Try out the program <tt>OnionAdder</tt> to see how
        command-line arguments work. 
      </li>
      <ul>
        <li>In order to pass command line arguments into your program,
          you must use Dr. Java's interactions pane to run the
          program.&nbsp; You can run the program by going to the
          interactions pane and typing the following command: <tt>java
          OnionAdder 300 55.532</tt>
        </li>
        <li>Let's take a look at the code in the <tt>OnionAdder.java</tt>
          program. Notice that putting a "+" sign between <tt>args[0]</tt>
          and <tt>args[1]</tt> concatenates the strings; the program
          needs to convert the inputs to integers or doubles before it
          can perform calculations with them.</li>

          <h2>Java Visualizer for Onion Adder</h2></li>
        <li><p>Add 2 command line arguments, 300 and 55.532, before clicking "visualize execution".</p></li>
        <li><p>Press "forward" to step through each line of the program.  Press "last" to skip to the end</p>
         <p>Output will be at the bottom, and the visualization will be on the right</p>
       </li>
       

        <iframe src="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=/*+%0A++++++++++*+Run+this+program+by+typing%3A++java+OnionAdder+300+55.532%0A++++++++++*+%0A++++++++++*+Expected+output+with+the+above+example%3A%0A++++++++++*+30055.532+%3C---Strings+concatenated+%0A++++++++++*+355.532+%3C---numbers+added+%0A++++++++++*+Shrek+has+355.532+onions.+%0A++++++++++*+%0A++++++++++*/%0A%0A++++++++++public+class+OnionAdder+%7B+%0A++++++++++public+static+void+main(String%5B%5D+args)+%7B%0A++++++++++int+a+%3D+Integer.parseInt(args%5B0%5D)%3B%0A++++++++++double+b+%3D+Double.parseDouble(args%5B1%5D)%3B%0A++++++++++System.out.println(args%5B0%5D+%2B+args%5B1%5D+%2B+%22+%3C---Strings+concatenated%22)%3B%0A++++++++++System.out.println(a+%2B+b+%2B+%22+%3C---numbers+added%22)%3B%0A++++++++++System.out.println(%22Shrek+has+%22+%2B+(a+%2B+b)+%2B+%22+onions.%22)%3B%0A++++++++%7D%0A++++++%7D%0A&mode=edit" frameborder="0" class="deck-frame" align = "middle" width="900" height="600"></iframe>
         <li class="slide"><h3>Too small? <a href="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=/*+%0A++++++++++*+Run+this+program+by+typing%3A++java+OnionAdder+300+55.532%0A++++++++++*+%0A++++++++++*+Expected+output+with+the+above+example%3A%0A++++++++++*+30055.532+%3C---Strings+concatenated+%0A++++++++++*+355.532+%3C---numbers+added+%0A++++++++++*+Shrek+has+355.532+onions.+%0A++++++++++*+%0A++++++++++*/%0A%0A++++++++++public+class+OnionAdder+%7B+%0A++++++++++public+static+void+main(String%5B%5D+args)+%7B%0A++++++++++int+a+%3D+Integer.parseInt(args%5B0%5D)%3B%0A++++++++++double+b+%3D+Double.parseDouble(args%5B1%5D)%3B%0A++++++++++System.out.println(args%5B0%5D+%2B+args%5B1%5D+%2B+%22+%3C---Strings+concatenated%22)%3B%0A++++++++++System.out.println(a+%2B+b+%2B+%22+%3C---numbers+added%22)%3B%0A++++++++++System.out.println(%22Shrek+has+%22+%2B+(a+%2B+b)+%2B+%22+onions.%22)%3B%0A++++++++%7D%0A++++++%7D%0A&mode=edit" target="_blank">Click here to open the visualizer in a new window</a></h3></li>

          <h5>If you're having trouble with the visualizer, or want to try running it in the terminal, here is the code for OnionAdder:</h5>
       <pre>      
        <code>

          /* 
          * Run this program by typing:  java OnionAdder 300 55.532
          * 
          * Expected output with the above example:
          * 30055.532 &lt;---Strings concatenated 
          * 355.532 &lt;---numbers added 
          * Shrek has 355.532 onions. 
          * 
          */

          public class OnionAdder { 
          public static void main(String[] args) {
          int a = Integer.parseInt(args[0]);
          double b = Double.parseDouble(args[1]);
          System.out.println(args[0] + args[1] + " &lt;---Strings concatenated");
          System.out.println(a + b + " &lt;---numbers added");
          System.out.println("Shrek has " + (a + b) + " onions.");
        }
      }

    </code>
</div>
<h3>General Structure of the N-Body Program</h3>
<div>
 <p> 
  We will be building up the program in several steps.&nbsp; Be
  certain to debug and test your program as you go.&nbsp; Even if you
  have not yet gotten to steps with graphical output, you can test
  your program easily by adding in temporary println()
  statements.&nbsp; If you read in a variable, print its value out to
  check it.&nbsp; If you do a computation, print out the result and
  check it.&nbsp; Once you're certain it is correct, you can remove
  these temporary println() statements.
</p>
<p> 
  The general structure of the program will be as shown below.&nbsp;
  The comments that are in <font color="#ff0000">RED</font> denote
  parts of the program that you will need to fill in.&nbsp; The
  purpose of this outline is to show you where each of the parts of
  the program will go:
</p>
<code>
  <pre>
    import processing.core.*; <br> <br>public class NBody extends PApplet { <br> <br>    public static void main(String[] args) { <br>  <br>        <font color="#ff0000">// process command line arguments and initialize variables (Part I)</font><br><br>        <font color="#ff0000">// read in the universe file (Part I)</font><br><br>        // start running the simulation<br>        PApplet.main(new String[]{"NBody"});  <br>    } <br><br><br>    <font color="#ff0000">// class-level variables</font><br><br>    public void setup() {<br>        <font color="#ff0000">// setup your sketch (Part II)</font><br><br>        <font color="#ff0000">// load in all images used in your simulation</font><font color="#ff0000"> (Part II)</font><code></code><br>    }<br>    <br>    public void draw() {<br>        <font color="#ff0000">// simulate one time step of the simulation (Part III)<br></font>    }<br>
  }</pre>
</code>
</div>
<h3>Configuration</h3>
<div>
  <ol>
   <li> Create a file <tt>NBody.java</tt> that will be your
    submission for this assignment. Copy the template for using the
    Processing library into the file.
  </li>
  <li>Download <a
    href="provided_files/nbody_data.zip">nbody_data.zip</a>
    and unzip it into the same folder as <tt>NBody.java</tt>. If
    your computer puts the contents in an nbody_data folder, move
    all the unzipped files back into the same folder as your <tt>NBody.java</tt>.&nbsp;</li>
    <li>Read Section 1.5. Review <code>StudentsFileProcessor.java</code>
      included in the zip file for help with reading from a file and
      parallel arrays. Compile and execute this program to make sure
      your system is configured properly. You can use the included
      file <code >students.txt</code> as input:
      <pre><b>% java StudentsFileProcessor students.txt</b></pre>
      If you have trouble compiling <code>StudentsFileProcessor.java</code>,
      check the Common Problems section. The booksite's standard
      library may not be correctly configured on your computer.
    </li>
  </ol>
</div>
</div>
<h3>Let's get this party started!</h3>
     <p><img src="http://cafewitteveen.files.wordpress.com/2012/03/tumblr_m0ni29eugr1qewacoo1_500.png" style="height: 200px"/></p>
</div> <!--end fragment-->


<!--NEW TAB-->
<div id="part1">
<h3>Reading Input </h3>
<div class="accordian">
  <h3>Variable for Filename</h3>
<div>
  <li>The first step is to declare a class-level variable for the
    filename (remember that class-level variables go outside of <code>setup()</code>,
    <code>draw()</code>, <code>main()</code>, etc. so that they
    are available in all of these functions):<br>
    <code>&nbsp;&nbsp;&nbsp;&nbsp;static String filename;</code><br>
    In this case, we also need to make the variable
    "static".&nbsp; Although we'll go over the details about <code>static</code>
    in a few more weeks, essentially static methods (like <code>main()</code>)
    can only access static variables.&nbsp; Since <code>main()</code>
    is static and we'll be setting the variable <code>filename</code>
    in <code>main()</code>, we have to make the variable <code>filename
  </code>static too.</li>
  <li>Add code to the beginning of<code> main()</code> that will
    initialize <code>filename</code> using the 3rd command line
    argument (<code>args[2]</code>).</li>
    <li>As a test, temporarily print out the value of <code>filename
    </code>immediately after you initialize it to make certain
    that it was read in correctly.</li>
    <li>Make certain that the call to <code>PApplet.main() </code>is
      the very last command in <code>main()</code>.&nbsp; This will
      start your simulation, and so any code after this in <code>main()</code>
      will not be called.</li>
      <li>Run your program to test it from the interactions pane in
        Dr. Java.&nbsp; Note that we're ignoring the two numbers
        passed into the program for now.&nbsp; To run your program,
        type:
        <p> <b><tt>% java NBody 15778000.0 25000.0 planets.txt</tt></b>
        </p>
      </li>
      <li>Check that it read in the filename correctly and printed it
        out.<br>
      </li>
      <li><font color="red"><b>Do not continue until you have tested
        and debugged this part.</b></font></li>
      </div>

      <h3>Reading from a file</h3>
      <div>
        <li>The next step is to read in
            the file describing the universe we will simulate.&nbsp; We will
            store this information into variables for use in our program. <br>
            The booksite's standard library provides the file <code>In.java</code>
            to support reading from a file.&nbsp; For a detailed example of
            reading from a file, you should consult <code>StudentsFileProcessor.java</code>.&nbsp;
            However, this section provides an overview of the necessary steps:
          </li>
          <li>Declare and initialize a variable in <code>main()</code>
            (we'll call it
            <code> inStream</code> in this example) to read from the file:<br></li>
           <li> <blockquote><pre>&nbsp;&nbsp;&nbsp;&nbsp;In inStream = new
              In(filename);&nbsp; // creates a variable inStream that we
              can use to read from the file</pre></blockquote></li>

              <li>Once the input stream is initialized, you can read from it
                using the following commands, just as with <code>StdIn</code>
                (see Section 1.5 of the textbook):</li>
                <ul>
                  <blockquote>
                    <pre>Section 1.5
                  boolean b = inStream.isEmpty();     // boolean value that is true if there are no more values, false otherwise
                  int i     = inStream.readInt();     // reads in an int from inStream
                  double d  = inStream.readDouble();  // reads in a double from inStream
                  boolean b = inStream.readBoolean(); // reads in a boolean from inStream
                  String s  = inStream.readString();  // reads in a string from inStream
                  String s  = inStream.readLine();    // reads in an entire line from inStream
                  String s  = inStream.readAll();     // reads in the entire file from inStream
                          </pre>
                        </blockquote>
                        <li>
                            The next step is to actually read in the file.&nbsp; To do
                            this, we'll need to understand the format of the file's
                            contents:<br>
                            <b>Input format.</b> The information for the universe is
                            contained in a text file with the following format:</li>
                            <ol>
                             <li> The first value is an integer <font color="blue"><b>N</b></font>
                              that represents the number of particles. </li>
                              <li> The second value is a real number <font color="blue"><b>R</b></font>
                                that represents the <em>radius</em> of the universe: assume
                                all particles will have <em>x</em>- and <em>y</em>-coordinates

                                that remain between -<em>R</em> and <em>R</em>. </li>
                                <li> The remaining <em>N</em> rows, each contain 6 values.
                                  The first two are the <em>x</em>- and <em>y</em>-coordinates

                                  of the initial position (<font color="blue"><b>px[]</b></font>
                                  and <font color="blue"><b>py[]</b></font>); the second two
                                  are the <em>x</em>- and <em>y</em>-components of the
                                  initial velocity (<font color="blue"><b>vx[]</b></font> and
                                  <font color="blue"><b>vy[]</b></font>); the fifth is the
                                  mass (<font color="blue"><b>m[]</b></font>); the last is a <tt>String</tt>
                                  that is the name of an image file used to display the
                                  particle (<font color="blue"><b>imgNames[]</b></font>). As
                                  an example, <tt>planets.txt</tt> contains data for our
                                  solar system (in SI units). </li></ol>
         
                                  <h3>Here's what the input file, planets.txt, looks like:</h3>
                                  <li> <blockquote>
                                    <pre>  % <b>more planets.txt</b>
                                      <font color="blue"><b>N</b></font> 5
                                      <font color="blue"><b>R</b></font> 2.50e+11
                                      1.4960e+11  0.0000e+00  0.0000e+00  2.9800e+04  5.9740e+24   earth.gif
                                      2.2790e+11  0.0000e+00  0.0000e+00  2.4100e+04  6.4190e+23   mars.gif
                                      5.7900e+10  0.0000e+00  0.0000e+00  4.7900e+04  3.3020e+23   mercury.gif
                                      0.0000e+00  0.0000e+00  0.0000e+00  0.0000e+00  1.9890e+30   sun.gif
                                      1.0820e+11  0.0000e+00  0.0000e+00  3.5000e+04  4.8690e+24   venus.gif
                                      <font color="blue"><b>px[]        py[]        vx[]        vy[]        m[]       imgNames[]</b></font>
                                    </pre>
                                  </blockquote></li>
                                  <li> Read in the data file <tt>planets.txt</tt> as described
    above using the methods from <code>StdIn</code>. Declare your
    fields as class-level variables, and initialize them in <code>main()</code>,
    reading their values from the file.<b></b></li>
    <li>Copy the code below and paste it at the end of <code>main()</code>
      (but above the call to <code>PApplet.main()</code>) to print it
      out in the same format. Right now, you are printing the
      information to aid in debugging; later, you will use this code
      to print out the state of the universe at the end of the
      simulation.
      <li><blockquote>
        <pre>System.out.printf("%d\n", N);
          System.out.printf("%.2e\n", R);
          for (int i = 0; i &lt; N; i++) {
          System.out.printf("%11.4e %11.4e %11.4e %11.4e %11.4e %12s\n", 
          px[i], py[i], vx[i], vy[i], m[i], imgNames[i]);
        }
      </pre>
       <ul>
      <li> Run your program:
        <p> <b><tt>% java NBody 15778000.0 25000.0 planets.txt</tt></b>
        </p>
        <p>Your program should print out the contents of <tt>planets.txt</tt>
          just as they appear above. You can ignore the two numeric
          command-line arguments for now, which control the time
          simulation, and focus on the reading <tt>planets.txt</tt>. </p>
        </li>
        <li> <font color="red"><b>Do not even think of continuing until
          you have tested and debugged this part.</b></font> </li>
        </ul>
    </blockquote></li>
      </div>
    </div>
</div> <!--end fragment-->

<!--NEW TAB-->
<div id="part2">
      <h3>Draw the Planets</h3>
      <div>
        <div class="accordian">
        <h3>Draw the Background</h3>
        <div> 
          <p> For this part, you will work entirely in the <code>setup()</code>
          function, declaring class-level variables as needed.</p>
          <ul>
            <li class="slide"> Set the size of the window to 500 by 500 pixels. </li>
            <li class="slide"> Write code to declare a class-level variable of type <code>PImage</code>
              called <tt>backdrop</tt> for the background and initialize it
              to <code>starfield.jpg</code> included in the zip:<br>
              <blockquote>
                <pre></pre>
                &nbsp;&nbsp;&nbsp;&nbsp;backdrop =
                loadImage(sketchPath("starfield.jpg")); //
                sketchPath("starfield.jpg") gets the file path to
                starfield.jpg<br>
                &nbsp;&nbsp;&nbsp;&nbsp;backdrop = backdrop.get(0, 0, width,
                height); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// get() crops the
                background image to be the same size as the canvas<br>
              </blockquote> </li>
              <li class="slide"> Write code to draw the background.&nbsp; Run your program to
                test it.</li>
              </div>


      <h3>Loop for Drawing Planets</h3>
        <div>
         <li>Add a class-level array of <code>PImage</code> variables to
                  hold the images for the planets via the following code:  <code>PImage[] images;</code>&nbsp; <br>
                </li>
                <ul>
                  <li>We will need to load all these images in <code>setup()</code>
                    and use them in <code>draw()</code>.&nbsp; The alternative
                    --- loading the images each iteration of the draw loop ---
                    would be extremely slow.&nbsp; So, we load them once in <code>setup()</code>
                    and use them throughout the program.</li>
                    <li>Write code to initialize each of the elements of the <code>PImage</code>
                      array using <tt>loadImage(sketchPath(imgNames[i]))</tt>,
                      looping the index <tt>i </tt>over all entries in <tt>imgNames.</tt>  To 
                      initialize a single element of the array, you can use the following code: <code>images[i] = loadImage(sketchPath(imgNames[i]));</code></li>
                    </ul>
                    <li>Write a loop to display images of the <tt>N</tt> bodies. <br>
                    </li>
                  </div>

         <h3>Coordinate System</h3>
        <div>
                   <li>The universe is represented in a much larger coordinate system than we can display, so we must transform 
                        all universe coordinates (e.g., <code>px[i]</code>, <code>py[i]</code>) to coordinates that we can display 
                        in the limited Processing sketch window.
                        <li class="slide">To transform between the universe coordinates and Processing window coordinates for the display, use the formulas below. The universe coordinates  
                          are specified on a scale of <font color="blue"><b>-R</b></font> to <font color="blue"><b>R</b></font>.
                          We have to shift this scale right by <font color="blue"><b>R</b></font>
                          because Processing's canvas has positive coordinates. You will
                          also have to cast these values into floats and negate the y
                          values to make the planets go counterclockwise.<br>
                     
                          <blockquote><pre>&nbsp;&nbsp;&nbsp;&nbsp;(px[i] + R) * width / (2.0 * R)
                            // computes the display x coordinate for the universe px coordinate<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;(-py[i] + R) * height / (2.0 * R) //
                            computes the display y coordinate for the universe py coordinate <pre></blockquote></li>
                            <li class="slide">Note that you should use these formulas ONLY for computing the display coordinates of the images from <code>px[i]</code>, <code>py[i]</code>.  
                              All calculations to update the body positions should use <code>px[i]</code>, <code>py[i]</code> -- never these formulas.
                              <li class="slide">Be sure to use <code>imageMode(CENTER)</code> so that your bodies are centered at the correct coordinates.
                              </ul>
              
                              <p>If all goes correctly, you should see the four stationary
                                planets and the sun.
                                <center> <img src="http://www.cis.upenn.edu/~cis110/14sp/hw/hw02/nbody-stationary.jpg" alt="N-body
                                  simulation" height="256" width="256"> </center>
                                </div>
      </div>
  </div>
</div> <!--end fragment-->

<!--NEW TAB-->
<div id="part3">
    <h3>Making the Planets Move</h3>
      <div class="accordian">
        <h3>Background</h3>
        <div>
         <p>The motion of particles is governed by a set
          of equations known as Newton's laws of motion and gravitation. (At
          the scale of the galaxy, we can treat planets as particles.) The
          equations contain two basic parts: <i>velocity</i>, which is the
          speed and direction that a particle is moving, and <i>acceleration</i>
          which are changes to speed and acceleration. Particles always move
          in a straight line at a constant speed unless some outside force
          (e.g. friction, gravity, or a push) creates an acceleration that
          changes the speed or direction. In our simulations, the only force
          will be gravity. First, however, we suggest implementing a
          universe without gravity and testing to make sure this works. </p></p>
         </section>
         <section class="slide">
          <p > Although we think of time as advancing continuously and of
            objects as moving continuously, computers are not good at
            simulating constant change. Instead, we settle for letting time
            jump forward in discrete time steps of Î”<i>t</i>, measured in
            seconds, called the <i>time quantum</i>. Particles will simply
            jump from the old position to the new position at each time step.
            By settings Î”<i>t</i> very small, we can get a very accurate
            simulation, but will need to do an enormous number of
            computations. Setting it very large will make the simulation very
            fast, but not very accurate. The scheme for doing this simulation,
            which we describe in detail below, is called the <i>leapfrog
            finite difference approximation scheme</i>. It numerically
            integrate Newton's equations (don't worry if that statement is
            meaningless to you), and is the basis for most astrophysical
            simulations of gravitational systems. </p>
          </div>

          <h3>The Time Loop</h3>
          <div>
       <li class="slide"> Create two class-level variables, <b><tt><font
              color="blue">T</font></tt></b> and <b><tt><font
              color="blue">dt</font></tt></b>. <tt>T</tt> is the
              time at which your simulation should end (the end of the
              universe, if you will), and <tt>dt</tt> is the amount of
              time that should pass in each step of your simulation.<br>
              (The latter is normally written "Î”t" in formulas, but
              variable names are limited to the Roman alphabet.) </li>
              <li class="slide"> In <code>main()</code>, use <tt>Double.parseDouble()</tt>
                to read the two numeric command-line arguments from <tt>args[0]</tt>
                and <tt>args[1]</tt> into the above variables <b><tt><font
                color="blue">T</font></tt></b> and <b><tt><font
                color="blue">dt</font></tt></b>.&nbsp; <br>
              </li>
              <ul class="slide">
                <li>Add temporary print statements for these variables, then
                  run your program and test that it works.&nbsp; Remove the
                  temporary print statements.<br>
                </li>
              </ul>
              <li> Create a class-level variable <code>t</code>. In <code>draw()</code>,
                increment this variable after checking it for whether the
                universe should be stopped; if it is time for the universe
                to stop, you can freeze the animation using <code>noLoop()</code>.
                Because <tt>T</tt> and <tt>dt</tt> are command-line
                arguments, rather than part of the input file, you can
                simulate the same universe at different speeds and for
                different lengths of time. </li>
                <li class="slide">Remove the print statements from <code>setup()</code> and
                  use them to print out the state of the universe after it
                  stops.</li>
                  <li class="slide"> In <code>setup()</code>, set the frame rate to 30 by
                    adding the command <tt>frameRate(30)</tt> to your code. The
                    argument "30" controls the speed of the animation; you can
                    increase it to speed up the animation or decrease it to slow
                    the animation down. Without it, your animation may flicker,
                    and if it is too short you animation may not run smoothly. </li>
                    <li class="slide"> Make sure your program compiles. There should be no
                      change yet when you run it. </li>
                                                        </ul>
                                                      </li>
                                                    </div>
          <h3>Redraw the Planets</h3>
          <div>
          <h3>Calculate the new position for every planet</h3>
        <ul>
          <li class="slide">Move the loop that draws the planets from <code>setup()</code>
            to <code>draw()</code>.&nbsp; Test your program; again
            there should be no change when you run it.<code></code><code></code><code></code>
          </li>
          <li class="slide">Inside <code>draw()</code>, before you redraw the
            planets, update the position (<i>p<sub>x</sub></i>,&nbsp;<i>p<sub>y</sub></i>)
            for every planet to (<i>p<sub>x</sub></i>&nbsp;+&nbsp;Î”<i>t</i>&nbsp;<i>v<sub>x</sub></i>,&nbsp;&nbsp;<i>p<sub>y</sub></i>&nbsp;+&nbsp;Î”<i>t</i>&nbsp;<i>v<sub>y</sub></i>).


            Remember that the positions and velocities of your planets
            are stored in the <tt>px</tt>, <tt>py</tt>, <tt>vx</tt>,
            and <tt>vy</tt> arrays.</li>
            <li class="slide"> Compile and run your program. For the <tt>planets.txt</tt>
              input, the sun should stay put in the center of the window,
              and the four planets should move straight up and off the
              screen. This is because their initial velocities specified
              in <tt>planets.txt</tt> all point straight up and we have
              not yet incorporated acceleration. </li>
              <li class="slide"> If your animation flickers or smears, check the Common
                Problems section</li>
              </ul>
              </div>

          <h3>Gravitational Forces</h3>
          <div>
<ul>
    <li> <h5>Gravitational Forces (Background):</h5> To update the
      particle velocities at each time step, you need to to
      compute the gravitational forces. Since the force depends on
      the relative positions of particles, it changes constantly
      and must be inside your time loop. On the other hand, you
      need it to update the velocities and therefore the
      positions, so it must come at the beginning of the time
      loop. The acceleration of a single particle, say the planet
      Earth, is simply the sum of forces exerted by all other
      planets on it (the <i>principle of superposition</i>). For
      each planet, you will need a loop over all other planets to
      sum up the force they exert on it. You will need to do this
      for all planets. </li>

    </section>
    <section class="slide" >
      <li> <h5>Gravitational Forces (Scaffolding Code):</h5> For now,
        assume the force that any planet exerts on any other planet
        is 0. (You will update this in the following steps.) Write
        code to compute the total force on each planet by summing up
        the pairwise forces (each planet with every other planet) as
        described above. The result will of course be zero, but will
        let you focus on the pairwise forces in the next step. <font
        color="red"><b class="slide">Make sure your code compiles at the end of
        this and every step.</b></font> </li>
      </section>

      <section class="slide">
        <li> <h5>Pairwise Gravitational Forces:</h5> The formula for
          the pairwise force <b>F</b> that one particle exerts on
          another is known as <i>Newton's law of universal
          gravitation</i>. It is the gravitational constant
          6.67&nbsp;Ã—&nbsp;10<sup>-11</sup>&nbsp;Nm<sup>2</sup>/kg<sup>2</sup>
          times the product of the two particles' masses, divided by
          the squared distance between them. The following figure illustrates
          the formula, using the Earth and the sun as representative
          particles:
          <center> <img src="http://www.cis.upenn.edu/~cis110/14sp/hw/hw02/nbody_formulas.png" alt="force diagram">
          </center>
        </li>

        <li> <h5><i>x</i>- and <i>y</i>- Force Components:</h5> Since
          the velocity is broken down into x- and y- components, the
          force needs to be too. Write code to compute the pairwise
          forces <i>F<sub>x</sub></i> and <i>F<sub>y</sub></i> using
          the formulas from the figure. Don't try and write this as
          one big formula; instead, write in in several small steps
          just as it is on the figure. <b>Don't worry if you don't
          fully understand the formulas. That's the computer's job.</b>
          </div>
          <h3>Variables</h3>
          <div>
section class="slide" id="Part III: Variables">
        <li> <b>Style and Readability Improvement:</b> Define a
          class-level variable <b><tt><font color="blue">G</font></tt></b>
          for the gravitational constant so the formulas will be
          easier to read. Initialize it to the value <tt>6.67e-11</tt>.
          This is Java-speak for 6.67&nbsp;Ã—&nbsp;10<sup>-11</sup>. </li>
          <li class="slide"> <b>Î”<i>x</i> and Î”<i>y</i>:</b> Be careful computing Î”<i>x</i>
            and Î”<i>y</i>. These are the distances in the x- and y-
            directions from the first planet to the second one, and can
            be negative. You should <b>not</b> take the absolute value
            of the differences between their x- and y- positions. </li>
          </section>

          <section class="slide" id="Part III: Acceleration and Velocity">
            <li> <h5>Acceleration:</h5> Compute the acceleration on each
              particle using the formulas <i>a<sub>x</sub>&nbsp;= F<sub>x</sub>&nbsp;/&nbsp;m</i>
              and <i>a<sub>y</sub>&nbsp;= F<sub>y</sub>&nbsp;/&nbsp;m</i>
              where <i>m</i> is the mass of the particle, and <i>F<sub>x</sub></i>
              and <i>F<sub>y</sub></i> are the sum of all pairwise forces
              exerted on the particle.<br>
              This is <i>Newton's second law of motion</i>. </li>
              <li class="slide"> <h5>Velocity:</h5> Using the acceleration you just
                computed, update the velocity (<i>v<sub>x</sub></i>, <i>v<sub>y</sub></i>)
                to (<i>v<sub>x</sub></i> + Î”<i>t</i> <i>a<sub>x</sub></i>,
                <i>v<sub>y</sub></i> + Î”<i>t</i> <i>a<sub>y</sub></i>).
                This gives you the direction and speed each particle should
                move at the current time, taking into account the
                gravitational pull of every other particle. </li>
                <li class="slide"> <h5>Order of computation:</h5> Remember that you must
                  update the velocity of <b>every</b> particle before you can
                  update any positions. Even though your program computes
                  these velocities one after the other, you have to maintain
                  the <i>illusion</i> that all planets are moving at the same
                  time. For instance, if you update the Earth's position
                  before computing Mars's velocity, then you will end up
                  computing Mars's velocity based on Earth's <i>future</i>
                  position, rather than its current position. </li>
          </div>
          <h3>Testing</h3>
          <div>
            <li> <b>Testing:</b> Compile and run your program. The
            planets should now orbit the sun. When testing, you should
            start with a single time step, making sure that it is
            working completely. Then try a small number of time steps,
            again making certain that it is working completely, before
            going on to a full year. It is much easier to diagnose
            problems for smaller time frames.</li>
          </ul>
        </li>
      </ol>
      <p class="slide"> After completing this section, review the requirements in <b>Your
        Program</b> at the top of this page, and make sure you are
        fulfilling the requirements exactly. Continue testing with other
        input files. </p>
        <p> </p>
          </div>
    </div>
</div> <!--end fragment-->

<div id="part4">
    <h3>But wait, there's more!</h3>
    <div>
      <div class="accordian">
      <h3>Sound</h3>
      <div>
      <p class="slide"> For an optional finishing touch, play the theme to <em>2001: A
        Space Odyssey</em> using StdAudio and the file <tt>2001.mid</tt>.
        You only need to add one line of code to the end of <tt>setup()</tt>
        to play the music: <br>
        <tt>StdAudio.play("2001.mid")</tt><br>
        On some computers, this adds a delay when the program starts up. For
        this reason, we recommended adding sound only when everything else
        works. It's entirely optional and not worth any points.</p>
      </div>
      <h3>More Precise Testing</h3>
      <div>
         <p> On the next slide there are the outputs your program should print after running on
            the <tt>planets.txt</tt> for various lengths of time. <b>Make
            sure you are printing your output at the very end of the program
            before comparing to these.</b> The exact numbers you get may be
            slightly different than the ones below if you do your computations
            in a slightly different order than our solution. <b>This is fine</b>,
            and is caused by rounding errors that affect the results
            differently depending on the precise order of statements. Also
            check to make sure that you are incrementing t after checking
            whether the universe should stop. <b>The biggest errors will
            appear to be in the sun's position.</b> Don't worry; all the
            values are printed in scientific notation. The planets' positions
            all end in <tt>e+10</tt> or <tt>e+11</tt>, meaning you should
            multiple the numbers by 10<sup>10</sup> or 10<sup>11</sup>. The
            exponents on the sun's position are on the scale of 10<sup>5</sup>.
            An error in the leading digit of the sun's position is therefore
            miniscule compared to the planet positions. Another way to think
            about this is that the window is 500&nbsp;Ã—&nbsp;500 pixels,
            representing coordinates ranging from -2.5&nbsp;Ã—&nbsp;10<sup>11</sup>
            to 2.5&nbsp;Ã—&nbsp;10<sup>11</sup>. Even if the leading digit of
            the sun's position is off by one, the error is on the order of
            10000, which is far less than one pixel in the window!</p>
          </section>
          <section class="slide" id="Testing Sample Results">
            <h3> Here are our results for a few sample inputs. </h3>
            <blockquote>
              <pre >% <b>java NBody 0.0 25000.0 planets.txt</b>           // zero steps (Note: Nothing will show up on screen for this case)
                5
                2.50e+11
                1.4960e+11  0.0000e+00  0.0000e+00  2.9800e+04  5.9740e+24    earth.gif
                2.2790e+11  0.0000e+00  0.0000e+00  2.4100e+04  6.4190e+23     mars.gif
                5.7900e+10  0.0000e+00  0.0000e+00  4.7900e+04  3.3020e+23  mercury.gif
                0.0000e+00  0.0000e+00  0.0000e+00  0.0000e+00  1.9890e+30      sun.gif
                1.0820e+11  0.0000e+00  0.0000e+00  3.5000e+04  4.8690e+24    venus.gif

                % <b>java NBody 25000.0 25000.0 planets.txt</b>       // one step
                5
                2.50e+11
                1.4960e+11  7.4500e+08 -1.4820e+02  2.9800e+04  5.9740e+24    earth.gif
                2.2790e+11  6.0250e+08 -6.3860e+01  2.4100e+04  6.4190e+23     mars.gif
                5.7875e+10  1.1975e+09 -9.8933e+02  4.7900e+04  3.3020e+23  mercury.gif
                3.3087e+01  0.0000e+00  1.3235e-03  0.0000e+00  1.9890e+30      sun.gif
                1.0819e+11  8.7500e+08 -2.8329e+02  3.5000e+04  4.8690e+24    venus.gif

                % <b>java NBody 50000.0 25000.0 planets.txt</b>       // two steps
                5
                2.50e+11
                1.4959e+11  1.4900e+09 -2.9640e+02  2.9799e+04  5.9740e+24    earth.gif
                2.2790e+11  1.2050e+09 -1.2772e+02  2.4100e+04  6.4190e+23     mars.gif
                5.7826e+10  2.3945e+09 -1.9789e+03  4.7880e+04  3.3020e+23  mercury.gif
                9.9262e+01  2.8198e-01  2.6470e-03  1.1279e-05  1.9890e+30      sun.gif
                1.0818e+11  1.7499e+09 -5.6660e+02  3.4998e+04  4.8690e+24    venus.gif

                % <b>java NBody 60000.0 25000.0 planets.txt</b>       // three steps
                5
                2.50e+11
                1.4958e+11  2.2349e+09 -4.4460e+02  2.9798e+04  5.9740e+24    earth.gif
                2.2789e+11  1.8075e+09 -1.9158e+02  2.4099e+04  6.4190e+23     mars.gif
                5.7752e+10  3.5905e+09 -2.9682e+03  4.7839e+04  3.3020e+23  mercury.gif
                1.9852e+02  1.1280e+00  3.9705e-03  3.3841e-05  1.9890e+30      sun.gif
                1.0816e+11  2.6248e+09 -8.4989e+02  3.4993e+04  4.8690e+24    venus.gif


                % <b>java NBody 31557600.0 25000.0 planets.txt</b>    // one year
                5
                2.50e+11
                1.4959e+11 -1.6531e+09  3.2949e+02  2.9798e+04  5.9740e+24    earth.gif
                -2.2153e+11 -4.9263e+10  5.1805e+03 -2.3640e+04  6.4190e+23     mars.gif
                3.4771e+10  4.5752e+10 -3.8269e+04  2.9415e+04  3.3020e+23  mercury.gif
                5.9426e+05  6.2357e+06 -5.8569e-02  1.6285e-01  1.9890e+30      sun.gif
                -7.3731e+10 -7.9391e+10  2.5433e+04 -2.3973e+04  4.8690e+24    venus.gif
          </pre>
        </blockquote>
      </div>
      <h3>Extra Credit</h3>
      <div>
        <p class="slide"> Submit a zip file containing an alternate universe (in our input
          format) along with the necessary image files. If its behavior is
          sufficiently interesting, we'll award extra credit. Your
          submission <b>must</b> be in a zip file, even if there are no
          images, so that our grading scripts can handle it correctly. </p>
          <p> </p>
          <p> </p>
          <h3>Challenges</h3>
          <p class="slide"> There are limitless opportunities for additional excitement and
            discovery here. Try adding other features, such as supporting
            elastic or inelastic collisions. Or, make the simulation
            three-dimensional by doing calculations for <em>x</em>-, <em>y</em>-,

            and <em>z</em>-coordinates, then using the <em>z</em>-coordinate
            to vary the sizes of the planets. Add a rocket ship that launches
            from one planet and has to land on another. Allow the rocket ship
            to exert force with the consumption of fuel.<br>
          </p>
          <p class="slide">Another idea is to generate a random starfield, and then have
            that starfield slowly move behind the planets.&nbsp; For an extra
            challenge, have it rotate around some center point.<br>
          </p>
      </div>

      <h3>Enrichment and Background</h3>
      <div>
        <div class="accordian">
            <h3>What is the music in <tt>2001.mid</tt>?</h3>
            <div>
               It's the
              fanfare to <a
              href="http://en.wikipedia.org/wiki/Also_sprach_Zarathustra_%28Richard_Strauss%29">
              Also sprach Zarathustra</a> by Richard Strauss. It was
              popularized as the key musical motif in Stanley Kubrick's 1968
              film <a
              href="http://www.rottentomatoes.com/m/1000085-2001_a_space_odyssey/">2001:
              A Space Odyssey</a>.
            </div>

            <h3>I'm a physicist. Why should I use the leapfrog method
              instead of the formula I derived in high school? In other
              words, why does the position update formula use the velocity
              at the <em>updated</em> time step rather than the previous
              one? Why not use the 1/2 a t^2 formula?</h3>
            <div>
          The leapfrog
            method is more stable for integrating Hamiltonian systems than
            conventional numerical methods like Euler's method or
            Runge-Kutta. The leapfrog method is <em>symplectic</em>, which
            means it preserves properties specific to Hamiltonian systems
            (conservation of linear and angular momentum,
            time-reversibility, and conservation of energy of the discrete
            Hamiltonian). In contrast, ordinary numerical methods become
            dissipative and exhibit qualitatively different long-term
            behavior. For example, the earth would slowly spiral into (or
            away from) the sun. For these reasons, symplectic methods are
            extremely popular for N-body calculations in practice. (Yeah,
            it's a bit complex.&nbsp; Hey, you asked!)
            <p> Here's a more complete explanation of how you should
              interpret the variables. The classic <em>Euler method</em>
              updates the position uses the velocity at time <em>t</em>
              instead of using the updated velocity at time <em>t</em> + Î”<em>t</em>.
              A better idea is to use the velocity at the midpoint <em>t</em>
              + Î”<em>t</em> / 2. The leapfrog method does this in a clever
              way. It maintains the position and velocity one-half time step
              out of phase: At the beginning of an iteration, (<em>p<sub>x</sub></em>,
              <em>p<sub>y</sub></em>) represents the position at time <em>t</em>
              and (<em>v<sub>x</sub></em>, <em>v<sub>y</sub></em>)
              represents the velocity at time <em>t</em> - Î”t / 2.
              Interpreting the position and velocity in this way, the
              updated position (<em>p<sub>x</sub></em> + Î”<em>t</em> <em>v<sub>x</sub></em>,
              <em>p<sub>y</sub></em> + Î”<em>t</em> <em>v<sub>y</sub></em>).
              uses the velocity at time <em>t</em> + Î”t / 2. Almost
              magically, the only special care needed to deal with the half
              time-steps is to initialize the system's velocity at time <em>t</em>
              = -Î”<em>t</em> / 2 (instead of <em>t</em> = 0.0), and you can
              assume that we have already done this for you. Note also that
              the acceleration is computed at time <em>t</em> so that when
              we update the velocity, we are using the acceleration at the
              midpoint of the interval under consideration. </p>
            </div>
            <h3>Interesting Links</h3>
            <div>
              <li>Here are some interesting <a
              href="http://en.wikipedia.org/wiki/Barycentric_coordinates_%28astronomy%29">
              two-body systems</a>, perhaps relevant to the extra credit.
              Here is beautiful <a
              href="http://cosmicvariance.com/2006/07/23/n-bodies/">21-body
              system</a> in a figure-8 - reproducing this one will
              definitely earn you extra credit. </li>
              <li>Here is a <a
                href="http://www.art.net/%7Esimran/GenerativeMusic/Kepler.html">website</a>
                that generates music using an N-body simulator!
            </div>
            <h3>Conclusion</h3>
            <div>
               <li>N-body simulations play a crucial role in our understanding of
            the universe. Astrophysicists use it to study stellar dynamics
            at the galactic center, stellar dynamics in a globular cluster,
            colliding galaxies, and the formation of the structure of the
            Universe. The strongest evidence we have for the belief that
            there is a black hole in the center of the Milky Way comes from
            very accurate N-body simulations. Many of the problems that
            astrophysicists want to solve have millions or billions of
            particles. More sophisticated computational techniques are
            needed.
          <li class="slide">The same methods are also widely used in molecular dynamics,
            except that the heavenly bodies are replaced by atoms, gravity
            is replaced by some other force, and the leapfrog method is
            called <em>Verlet's method</em>. With van der Waals forces, the
            interaction energy may decay as 1/R^6 instead of an inverse
            square law. Occasionally, 3-way interactions must be taken into
            account, e.g., to account for the covalent bonds in diamond
            crystals.
            </div>
        </div>
      </div>
      <h3>Common Problems</h3>
      <div>
        <div class="accordian">
          <h3>Standard Libraries Missing</h3>
          <div>
            <p> For this assignment, you
            need to use the booksite's standard libraries. If you ran the
            introcs installer, these should be set up for you, and
            everything should "just work." If not, you may need to download
            <a href="http://introcs.cs.princeton.edu/java/stdlib/In.java">In.java</a>
            into the same folder as your NBody.java.</p>
          </div>
            <h3>My planets fly off the top right corner of the screen.</h3>
          <div>
            You have probably flipped the order of particles when computing
              Î”<i>x</i> and Î”<i>y</i>. As a result, the signs on all your
              distances are all reversed, and gravity is repelling planets
              from each other instead of attracting them. (Video is slowed for
              illustration.)
              <p> <iframe
                src="http://www.youtube.com/embed/Bi6scfHWLu4?rel=0"
                allowfullscreen="" frameborder="0" height="315" width="420"></iframe>
          </div>
            <h3>My planets all disappear or jump to the top left corner as
                soon as I start running the program.</h3>
          <div>
            <p> Check your loop for
                  computing the pairwise forces between particles. Are you
                  computing the force exerted by a particle on itself (e.g.
                  Earth's gravitational pull on itself)? If you are, do the
                  computation by hand to see exactly what it would give you. That
                  should help you understand why this is a bad idea, and why the
                  planets jump the way they do. (Video is slowed for
                  illustration.)
                  <p> <iframe
                    src="http://www.youtube.com/embed/j73bytX-dzo?rel=0"
                    allowfullscreen="" frameborder="0" height="315" width="420"></iframe>
                  </p></p>
          </div>
          <h3>My planets go around the sun, then zoom off the lower left
                corner.</h3>
          <div>
            <p>You are not summing up the pairwise forces
                  correctly. Run your program with a small value of <tt>T</tt>
                  (e.g. 51000) so it runs for only two or three time steps. Print
                  out the value of every variable before and after you change its
                  value (or right after you first initialize it). Include enough
                  information in the print statement so you can tell which
                  variable you are printing out. Make sure to print all loop
                  variables as well so you can tell from the output exactly when
                  each print statement occured. Run the program, and examine the
                  output. Ask yourself each time a variable changes whether its
                  starting and new values make sense. (You don't need to work out
                  the exact values of the variables to figure out if they make
                  sense in this case.) Once you've found the problem, you may want
                  to move the declarations of some variables farther inside your
                  loops to the first point you need them. Declaring variables as
                  late as possible is one strategy to avoid the type of bug you
                  are encountering. (Video is slowed for illustration.)
                  <p> <iframe
                    src="http://www.youtube.com/embed/i26ur1cJRjU?rel=0"
                    allowfullscreen="" frameborder="0" height="315" width="420"></iframe>
                  </p></p>
          </div>
          <h3>My planets are flickering.</h3>
          <div>
            <p>You are not calling <tt>frameRate()</tt>.</p>
          </div>
          <h3>My planets are flickering, and I only see one of them at a
                  time.</h3>
                  <div>
                    <p>You are redrawing the background before drawing each
                    planet, instead of redrawing it once per timestep. As a result,
                    you keep covering up each planet as soon as you draw it.</p>
                  </div>
          <h3>My planets "smear" accross the screen.</h3>
          <div>
            <p>You are drawing
                        the background once at the beginning of the programming instead
                        of once each time step. Processing does not erase the window
                        automatically. In this program, we're never erasing it at all.
                        Instead, we keep covering the old planet positions up with the
                        starfield image, which happens to be exactly the same size as
                        the window. If you don't keep redrawing the background before
                        drawing the planets at their new positions, the old planets are
                        still there, causing the smearing effect.</p>
          </div>

        </div>

      </div>
    </div>
    </div>
  </div>
  <!--NEW TAB-->
<div id="part5">
<h3>Submission</h3>
  <p>Submit NBody.java and a completed&nbsp;<a href="http://www.cis.upenn.edu/~cis110/14sp/hw/hw02/readme_nbody.txt/">readme_nbody.txt</a> file using the submission link on the &nbsp;<a href="https://fling.seas.upenn.edu/~cis110/cgi-bin/14sp/submit.cgi">website</a> .</p>
</div>
</div>

</div>



  </body>
  <script>
  $( ".accordian" ).accordion({ animate: 200, collapsible: true, active: false, heightStyle: "content" });
  //copy css from #accordian to .accordian
  </script>
  </html>